var tipuesearch = {
  "pages": [
    {
      "title": "Hello, HPy",
      "text": "Welcome to the shiny new HPy blog!\nHPy has been around for a while now. The initial discussion started during\nEuroPython 2019, in the good old times when we could still go to conferences\nand have real-life meetings. Since then, HPy progressed a lot from the\npoint of view of the actual code, but we have been a bit too silent\nw.r.t. communicating what we are doing to the external world and to the broader\nPython community. Hopefully, now that this blog is online we will do a better\njob at periodically communicating the status of HPy, so make sure to\nsubscribe to the RSS feed.\n\n\nWhat is HPy?\nQuoting the frontpage of our website:\n\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>.\n\nThe official Python/C API is\nspecific to the current implementation of CPython: it exposes many\ninternal details which makes it hard:\n\n\nto implement it for other Python implementations (e.g. PyPy, GraalPython,\n    Jython, IronPython, etc.)\n\n\nto experiment with new things inside CPython itself: e.g. using a GC\n    instead of refcounting, or to remove the GIL.\n\nto correctly check things like refcount handling: the external API gets mixed in with implementation details that should be hidden.\n\nOver the years, it has become evident that\nemulating the Python/C API in an efficient way is challenging,\nif not impossible. The main goal of HPy is expose a C API which is possible\nto implement in an efficient way on a number of very diverse Python\nimplementations.\nThere are several advantages to writing your C extension in HPy:\n\n\nit runs much faster on PyPy, and at native speed on CPython\n\n\nit is possible to compile a single binary which runs unmodified on all\n    supported Python implementations and versions\n\n\nit is simpler and more manageable than the Python/C API\n\n\nit provides an improved debugging experience: in \"debug mode\", HPy\n    actively checks for many common mistakes such as reference leaks and\n    invalid usage of objects after they have been deleted. It is possible to\n    turn the \"debug mode\" on at startup time, without needing to recompile\n    Python or the extension itself\n\n\nSee also the official docs for a more in-depth\noverview.\nShow me an example\nThis is a \"normal\" Python/C extension:\n2021/03/hello-hpy/hello_old.c  (Source)#include <Python.h>\n\nstatic PyObject* add(PyObject* self, PyObject* args) {\n    long a, b;\n    if (!PyArg_ParseTuple(args, \"ll\", &a, &b))\n        return NULL;\n    return PyLong_FromLong(a+b);\n}\n\nstatic PyMethodDef HelloMethods[] = {\n    {\"add\", (PyCFunction)add, METH_VARARGS, \"add two integers\"},\n    {NULL, NULL, 0, NULL}\n};\n\nstatic struct PyModuleDef moduledef = {\n    PyModuleDef_HEAD_INIT,\n    \"hello_old\",\n    \"hello example using the old Python/C API\",\n    -1,\n    HelloMethods,\n};\n\nPyMODINIT_FUNC\nPyInit_hello_old(void) {\n    return PyModule_Create(&moduledef);\n}\n\nWe can compile it with a simple setup.py:\nfrom setuptools import setup, Extension\nsetup(\n    name=\"hello\",\n    ext_modules = [\n        Extension('hello_old', ['hello_old.c']),\n    ],\n)\n\n$ python setup.py build_ext --inplace\n...\n$ python \n>>> import hello_old\n>>> hello_old.add(10, 20)\n30\n\nNow, let's start to uncover the HPy equivalent, piece by piece:\n#include <hpy.h>\n\nHPyDef_METH(add, \"add\", add_impl, HPyFunc_VARARGS,\n            .doc = \"add two integers\");\n\nstatic HPy add_impl(HPyContext ctx, HPy self, HPy *args, HPy_ssize_t nargs) {\n    long a, b;\n    if (!HPyArg_Parse(ctx, NULL, args, nargs, \"ll\", &a, &b))\n        return HPy_NULL;\n    return HPyLong_FromLong(ctx, a+b);\n}\n\nThere are a bunch of things which are different from the usual C-extension module:\n\n\nthe former PyObject * is now HPy, which we call \"a handle\". Handles are\n  similar to PyObject *, but are completely opaque: for more information,\n  see the\n  official docs.\n\n\nThere is an additional parameter, HPyContext ctx. One of the problems of\n  the old API is that often it implicitly relies on the existence of a\n  per-thread or per-subinterpreter local state. HPyContext makes this state explicit. This\n  makes the whole API more regular and makes it possible to develop new\n  interesting features such as the\n  Universal ABI\n  and the Debug mode.\n\n\nHPy introduces the concept of HPyDefs. HPyDef_METH is a macro which\n  generates the definition of an HPyDef static constant named add, which\n  represents the definition of a Python method implemented by the C function\n  add_impl. In this specific example HPyDef_METH contains more or less the\n  same informations as the old PyMethodDef, but HPyDef are more\n  general. For example, when defining custom types you can use things like\n  HPyDef_SLOT, HPyDef_GETSET, etc.\n\n\nNotice that we no longer need the cast to (PyCFunction). One of the\n  biggest advantages of HPyDef_METH is that since it's a macro, it can\n  automatically generate a forward declaration for add_impl, with the\n  correct signature. This means that if you use the wrong number and/or type\n  of parameters, you get a nice compile-time error instead of an obscure crash\n  at runtime.\n\n\nThe signature corresponding to HPyFunc_VARARGS is slighly different than\n  the old METH_VARARGS: we pass positional arguments as a C array instead of\n  a Python tuple. This means that it is possible to call the function without\n  having to allocate a Python tuple, and for example the PyPy implementation\n  of HPy takes advantage of that. This is very similar to CPython's\n  VectorCall protocol.\n\n\n\nNote\nIn this post, we are using a slightly old version of HPy. If you try with\na newer version you should use HPyContext *ctx instead of HPyContext ctx.\nSee also Issue #150\nand PR #182.\n\nLet's continue our tour of hello_new.c:\nstatic HPyDef *hello_defines[] = {\n    &add,\n    NULL\n};\n\nstatic HPyModuleDef moduledef = {\n    HPyModuleDef_HEAD_INIT,\n    .m_name = \"hello_new\",\n    .m_doc = \"hello example using the new HPy API\",\n    .m_size = -1,\n    .defines = hello_defines,\n};\n\nHPy_MODINIT(hello_new)\nstatic HPy init_hello_new_impl(HPyContext ctx) {\n    return HPyModule_Create(ctx, &moduledef);\n}\n\nThis is pretty similar to the old code. The biggest change is that instead of\ndeclaring an array of PyMethodDef, we create an array of HPyDef as\ndiscussed above.\nFinally, we need to modify setup.py. Compiling an HPy extension is as easy\nas adding setup_requires=['hpy.devel'] and use hpy_ext_modules:\n2021/03/hello-hpy/setup.py  (Source)from setuptools import setup, Extension\nsetup(\n    name=\"hello\",\n    ext_modules = [\n        Extension('hello_old', ['hello_old.c']),\n    ],\n    hpy_ext_modules = [\n        Extension('hello_new', ['hello_new.c']),\n    ],\n    setup_requires=['hpy.devel'],\n)\n\nCompiling HPy extensions\nIn this demo, we will show how to setup an environment to try HPy and compile\nextensions on both CPython and PyPy.\nAt the moment HPy is still in its early stages and the API is still subject to\nchange, so we have not done any official release yet. For the same reason, if\nyou want to use HPy on PyPy, you need to manually ensure to install a version\nwhich is supported. This is just temporary, and this kind of things will be\nsorted out automatically once we start to roll out official releases.\nSo, we need to install HPy from the github repo. Moreover, the HPy\nimplementation inside PyPy is lagging behind a little, so we will install a\nslightly old revision:\n\n\nHPy revision eb07982\n\n\nnightly build of the PyPy hpy branch: a2f7c80062e8 for linux64\n\n\nPyPy nighly builds: main page and\n  hpy branch\n\n\nsource code of this example\n\n\nThe first step is to create a venv for CPython and install hpy:\n$ python3 -m venv tryhpy\n$ . tryhpy/bin/activate\n$ pip install wheel\n$ pip install git+git://github.com/hpyproject/hpy.git@eb07982\n\nTo install a nightly build of PyPy it is enough to unpack the tarball and run\n-m ensurepip. We can check what is the HPy version supported by PyPy by\ncalling hpy.universal.get_version():\n$ curl -O http://buildbot.pypy.org/nightly/hpy/pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2\n$ tar xf pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2\n$ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy -m ensurepip\n\n$ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy\n>>>> import hpy.universal\n>>>> hpy.universal.get_version()\n('0.1.dev959+geb07982', 'eb07982')\n\nNow that our enviroment is ready, we can compile and try our extensions:\n$ cd /path/to/example/\n$ . /path/to/tryhpy/bin/activate    # activate the venv\n$ python setup.py build_ext --inplace\n[...]\n\n$ ls -1 *.so\nhello_new.cpython-38-x86_64-linux-gnu.so\nhello_old.cpython-38-x86_64-linux-gnu.so\n\n$ python\n>>> import hello_old, hello_new\n>>> hello_old.add(10, 20)\n30\n>>> hello_new.add(30, 40)\n70\n>>>\n\nIt worked! One important thing to note is the filename of hello_new:\n.cpython-38-x86_64-linux-gnu.so is the standard filename for CPython 3.8\nextension modules. This happens because by default hpy_ext_modules targets\nthe\nCPython ABI. As\nsuch, from the point of view of CPython hello_new is indistinguishable from\nhello_old. It also means that HPy is required only to compile it but not to\nimport it later. Finally, we expect the performance to be the very same as the\nextensions using the old API.\nHowever, we can also explicitly ask HPy to produce an \"universal binary\",\nwhich targets the\nHPy Universal ABI:\nas the name implies, universal binaries can be imported by CPython, but also\nby alternative implementations such as PyPy. We can build universal binaries\nby passing --hpy-abi=universal to setup.py:\n$ # clean the previous build\n$ rm -rf build/ *.so\n\n$ python setup.py --hpy-abi=universal build_ext --inplace\n$ ls -1 *.so\nhello_new.hpy.so\nhello_old.cpython-38-x86_64-linux-gnu.so\n\nNote the filename: hello_old is still a CPython-specific extension, but\nhello_new.hpy.so is an universal binary. Once compiled, you can import it as\nusual:\n$ python\n>>> import hello_old, hello_new\n>>> hello_old.add(10, 20)\n30\n>>> hello_new.add(30, 40)\n70\n>>> hello_new.__file__\n'/.../hello-hpy/hello_new.hpy.so'\n\n\nNote\nAt the moment of writing, because of\nIssue #191 if you try to\nprint the repr of hello_new, you see something like this (note the .py\nextension):\n>>> hello_new\n<module 'hello_new' from '/.../hello-hpy/hello_new.py'>\n\n\nNote that on its own, CPython does not know how to import .hpy.so\nfiles. The magic is done by the hello_new.py, which is automatically\ngenerated by setup.py:\n$ cat hello_new.py\n[...]\ndef __bootstrap__():\n    [...]\n    from hpy.universal import load_from_spec\n    ext_filepath = pkg_resources.resource_filename(__name__, 'hello_new.hpy.so')\n    m = load_from_spec(Spec('hello_new', ext_filepath))\n    [...]\n    sys.modules[__name__] = m\n\n__bootstrap__()\n\nFinally, we can try to import our shiny new universal binary on PyPy:\n$ /path/to/pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy\n>>>> import hello_new\n>>>> hello_new.add(10, 20)\n30\n>>>> hello_new.__file__\n'/.../hello-hpy/hello_new.hpy.so'\n>>>>\n\nThat's all you need to get started with HPy. What we presented today is just\nthe basics, of course: in the next posts we will dig more into the technical\ndetails, and show more interesting features than just a hello world.\nStay tuned!",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/03/hello-hpy/"
    },
    {
      "title": "HPy - A better C API for Python",
      "text": "What is HPy?\nHPy provides a new API for extending Python in C.  In other words, you use\n#include <hpy.h> instead of #include <Python.h>.\n\n\nWhat are the advantages of HPy?\n\nZero overhead on CPython: extensions written in HPy runs at the same\nspeed as \"normal\" extensions.\nMuch faster on alternative implementations such as PyPy, GraalPython.\nDebug Mode: in debug mode, you can easily identify common problems such\nas memory leaks, invalid lifetime of objects, invalid usage of APIs. Have\nyou ever forgot a Py_INCREF or Py_DECREF? The HPy debug mode will\ndetect this mistakes for you.\nUniversal binaries: extensions built for the HPy Universal ABI can be\nloaded unmodified on CPython, PyPy, GraalPython, etc.\nNicer API: the standard Python/C API shows its age. HPy is designed to\novercome some of its limitations, be more consistent, produce better quality\nextensions and to make it harder to introduce bugs.\n\n\n\nCurrent status\nHPy is still in an early stage of development and there is no official release\nyet. We hope to make our first alpha release in the next months but we don't\nhave any ETA.\nThe Python/C API is huge and at the moment only a small fraction of it is\navailable in HPy. We are experimenting by porting existing extensions to HPy\nand adding/designing new functionalities on a per-need basis.\nWe welcome your design input or adventurous alpha testing.\n\n\nHPy-compatible extensions\nThe extensions that we are experimenting with include:\n\nultrajson-hpy: this was the first real-world module to be ported to HPy. It is\na nice fit because it only exports functions (as opposed as custom types)\nand requires only a small number of API functions.\npiconumpy: as the name suggests, this is a minimal numpy-like module which\ndefines a custom type (similar to ndarray but with many fewer features of\ncourse).\nnumpy-hpy: one of our ambitious goals is to port numpy to HPy, and to use this\nexperience to better understand how to design the API. This is still at a\nvery early stage though.\n\n\n\nThis website and the logo are ugly\nWe know: we have expertise in Virtual Machines, Compilers, low-level\nprogramming, etc, but zero expertise in web development or graphic\ndesign. PRs are welcome ;)\n\n\nMore info\n\nOfficial docs\nHPy blog\nGithub repository\n#hpy IRC channel on the Freenode server\n\n\n\nRecent blog posts\n\n\n    \n            \n            2021-03-29 10:00\n            \u00a0\n            Hello, HPy",
      "tags": "",
      "url": "https://hpyproject.org/"
    }
  ]
};